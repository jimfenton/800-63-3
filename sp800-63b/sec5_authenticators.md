##5. Authenticator and Verifier Requirements

Section 4 specified the types of authenticators that may be used for each of the three Authenticator Assurance Levels (AALs). This section provides the detailed requirements for each of the authenticator types. With the exception of validation requirements specified in Section 4, the technical requirements for each of the token types is the same regardless of the level at which it is used. For example, a multi-factor cryptographic device may be used at any AAL; the requirements are not different except that validation is not required at AAL 1 and may be asserted by the device's manufacturer at AAL 2.

###5.1. Memorized Secrets

A Memorized Secret authenticator (commonly referred to as a *password* or *PIN* if it is numeric) is a secret value that is intended to be chosen and memorizable by the user. Memorized secrets need to be of sufficient complexity and secrecy that it would be impractical for an attacker to guess or otherwise discover the correct secret value.

####5.1.1. Memorized Secret Authenticators

Memorized secrets MUST be at least 8 characters in length. Subscribers should expect that some values for memorized secrets may be disallowed based on their appearance on a blacklist of compromised values. No other complexity requirements for memorized secrets are imposed; a rationale for this is presented in Appendix A.

Claimants authenticating via memorized secrets SHOULD ensure that the communication channel authenticates the Verifier (e.g., using X.509 certificates they trust or can verify) and uses approved encryption (e.g., a current version of TLS) before entering their memorized secret.

####5.1.2. Memorized Secret Verifiers

Verifiers MUST require memorized secrets to be at least 8 characters in length, and MAY impose a higher minimum. Verifiers MUST permit memorized secrets to be at least 64 characters in length. All printing ASCII (ref) characters as well as the space character MUST be acceptable in memorized secrets; Unicode (ref) characters SHOULD be accepted as well.

Memorized secret verifiers MUST NOT permit the subscriber to store a "hint" that is accessible to an unauthenticated claimant. Verifiers also MUST NOT prompt subscribers to use specific types of information (e.g., "What was the name of your first pet?") when choosing memorized secrets.

When processing requests to establish and change memorized secrets, verifiers SHOULD compare the prospective secrets against a dictionary of known commonly-used and/or compromised values. If the chosen secret is found in the dictionary, the subscriber SHOULD be prompted to choose a different value.

Verifiers SHOULD NOT impose other composition rules (mixtures of different character types, for example) on memorized secrets. Verifiers SHOULD NOT require memorized secrets to be changed arbitrarily (e.g., periodically) unless there is evidence of a breach of authentication information.

Verifiers MUST use approved encryption and MUST authenticate themselves to the claimant (e.g., through the use of a X.509 certificate acceptable to the claimant) when requesting memorized secrets in order to provide resistance to eavesdropping and phishing attacks.

Verifiers MUST store memorized secrets in a form that is resistant to offline attacks. Secrets must be hashed with a "salt" value using an approved hash function. The "salt" value MUST be a 32 bit (or longer) random value generated by an approved random number generator and is stored along with the hash result. A keyed hash function (e.g., HMAC), with the key stored separately from the hashed authenticators (e.g., in a hardware security module) SHOULD be used to further resist dictionary attacks against the stored hashed authenticators. ***Say something about hash iterations.  Rate limiting??***

###5.2. Look-up Secrets

A look-up secret authenticator is a physical or electronic record that stores a set of secrets shared between the Claimant and the CSP. The Claimant uses the authenticator to look up the appropriate secret(s) needed to respond to a prompt from the Verifier. For example, a Claimant may be asked by the Verifier to provide a specific subset of the numeric or character strings printed on a card in table format.

####5.2.1 Look-up Secret Authenticators
Look-up secret authenticators (the media and devices containing look-up secrets) MUST be protected by the subscriber against theft or duplication. If the authenticator uses look-up secrets sequentially from a list, the subscriber MAY dispose of used secrets, but only after a successful authentication. The subscriber MUST contact their CSP immediately if theft or duplication of the authenticator is suspected.

CSPs creating look-up secret authenticators MUST use an approved random number generator to generate the list of secrets, and MUST deliver the authenticator securely to the subscriber and to the verifier. ***Describe what delivery methods are acceptable.*** Look-up secrets MUST have at least 64 bits of entropy, or MUST have at least 20 bits of entropy if the number of failed authentication attempts is limited as described in Section 5.2.2.

Claimants authenticating via look-up secrets SHOULD ensure that the communication channel authenticates the Verifier (e.g., using X.509 certificates they trust or can verify) and uses approved encryption (e.g., a current version of TLS) before entering a secret they have looked up.

####5.2.2. Look-up Secret Verifiers

Verifiers of look-up secrets MUST prompt the claimant for the next secret from their authenticator or for a specific (i.e., numbered) secret. A given secret from an authenticator MUST only be used successfully only once; therefore, a given authenticator can only be used for a finite number of successful authentications.

Verifiers MUST store look-up secrets in a form that is resistant to offline attacks. Secrets having less than 64 bits of entropy MUST be hashed with a "salt" value using an approved hash function. The "salt" value MUST be a 32 bit (or longer) random value generated by an approved random number generator and is stored along with the hash result. A keyed hash function (e.g., HMAC), with the key stored separately from the hashed authenticators (e.g., in a hardware security module) SHOULD be used to further resist dictionary attacks against the stored hashed authenticators. Secrets having at least 64 bits of entropy MAY simply be hashed using an approved hash function.

Look-up secrets MUST be generated using an approved random number generator and MUST have at least 20 bits of entropy. When look-up secrets have less than 64 bits of entropy, the verifier MUST implement a throttling mechanism that effectively limits the number of failed authentication attempts an Attacker can make on the Subscriber’s account to 100 or fewer in any 30-day period. See section TBD for further guidance on throttling.

Verifiers MUST use approved encryption and MUST authenticate themselves to the claimant (e.g., through the use of a X.509 certificate acceptable to the claimant) when requesting look-up secrets in order to provide resistance to eavesdropping and phishing attacks.

###5.3. Out of Band

An Out of Band authenticator is a physical device that is uniquely addressable and can receive a Verifier-selected secret for one-time use. The device is possessed and controlled by the Claimant and supports private communication over a secondary channel that is separate from the primary channel for e-authentication. The claimant presents the received secret to the verifier using the primary channel for e-authentication.

***Significant change:*** Two key requirements are that the device be uniquely addressable and that communication over the secondary channel be private. Some of the mechanisms that have been used in the past for out of band authentication, such as mobile telephone text messaging and telephone calls, are no longer considered uniquely addressable since they may be associated with Internet telephony services rather than physical devices. Accordingly, mechanisms such as smartphone applications employing secure communications protocols are required for out-of-band authenticators.

####5.3.1. Out of Band Authenticators
Out of band authenticators MUST be protected by the subscriber against theft or loss. The subscriber MUST contact their CSP immediately if loss or theft of the authenticator is suspected. ***This is getting repetitive -- perhaps goes in lifecycle section?***

Out of band authenticators MUST NOT display the authentication secret on a device that is locked by the owner (i.e., requires an entry of a PIN or passcode). However, authenticators MAY indicate the receipt of an authentication secret on a locked device.

The out of band authenticator MUST establish a secure communication channel with the  verifier that is resistant to man-in-the-middle attacks (e.g., TLS using certificates that are trusted by the authenticator) in order to retrieve the out of band secret. This secure communication channel is considered to be out of band with respect to the primary communication channel, even if they terminate on the same device, provided the device does not leak information from one to the other.

The out of band authenticator MUST uniquely authenticate itself using at least a 124-bit identifying key to the verifier in order to receive the authentication secret. This key SHOULD be stored in the most secure storage available on the device (e.g., keychain storage).

####5.3.2. Out of Band Verifiers

Out of band verifiers MUST generate a random authentication secret with at least 20 bits of entropy using an approved random number generator. They then optionally signal the device containing the subscriber's authenticator to indicate readiness to authenticate.

The verifier then waits for a secure (e.g., TLS) connection from an authenticator and verifies the authenticator's identifying key. The verifier MUST NOT store the identifying key itself, but MUST use a verification method such as hashing (using an approved hash function) or proof of possession of the identifying key to uniquely identify the authenticator. Once authenticated, the verifier transmits the authentication secret to the authenticator and waits for the secret to be returned on the primary communication channel. The authentication secret MUST be considered invalid if not received over the primary channel within 5 minutes.

***Send the website/service name to the authenticator too?***

If the authentication secret has less than 64 bits of entropy, the verifier MUST implement a throttling mechanism that effectively limits the number of failed authentication attempts an Attacker can make on the Subscriber’s account to 100 or fewer in any 30-day period. See section TBD for further guidance on throttling.

###5.4. Single Factor OTP Device

A single factor OTP device is a hardware device that supports the spontaneous generation of one-time passwords. This device has an embedded secret that is used as the seed for generation of one-time passwords and does not require activation through a second factor. Authentication is accomplished by using the authenticator output (i.e., the one-time password) in an authentication protocol, thereby proving possession and control of the device. A one-time password device may, for example, display 6 characters at a time.

Single factor OTP devices are similar to look-up secret authenticators with the exception that the secrets are cryptographically generated by the authenticator and verifier and compared by the verifier. The secret is computed based on a nonce that may be time-based or from a counter on the authenticator and verifier.

####5.4.1. Single Factor OTP Authenticators

Single factor OTP authenticators contain two persistent values. The first is a symmetric key that persists for the lifetime of the device. The second is a nonce that is changed each time the authenticator is used or is based on a real-time clock.

The secret key MUST be a 128-bit or longer AES key or of equivalent strength. The nonce MUST be of sufficient length to ensure that it is unique for each operation of the device.

The authenticator output is obtained by using an approved block cipher or hash function to combine the key and nonce in a secure manner. The authenticator output MAY be truncated to as few as 6 decimal digits (approximately 20 bits of entropy). Note that when the authenticator output is truncated in this manner a given output value may repeat; the term "one-time password" is somewhat of a misnomer.

If the nonce used to generate the authenticator output is based on a real-time clock, the nonce MUST be changed at least once every 2 minutes. The OTP value associated with a given nonce MUST be accepted only once.

####5.4.2. Single Factor OTP Verifiers

Single factor OTP verifiers effectively duplicate the process of generating the OTP used by the authenticator. As such, the symmetric keys used by authenticators are also present in the verifier, and MUST be strongly protected against compromise.

***Say something about OTP verifiers and synchronization. How much jitter is allowed?***

If the authenticator output has less than 64 bits of entropy, the verifier MUST implement a throttling mechanism that effectively limits the number of failed authentication attempts an Attacker can make on the Subscriber’s account to 100 or fewer in any 30-day period. See section TBD for further guidance on throttling.

***SF OTP values should be able to be entered via USB, right? MF said that explicitly, but not SF.***

###5.5. Multi-Factor OTP Devices

A multi-factor (MF) OTP device hardware device that generates one-time passwords for use in authentication and which requires activation through a second factor of authentication. The second factor of authentication may be achieved through some kind of integral entry pad, an integral biometric (e.g., fingerprint) reader or a direct computer interface (e.g., USB port). The one-time password is typically displayed on the device and manually input to the Verifier as a password, although direct electronic input from the device to a computer is also allowed. The authenticator output is the one-time password. For example, a one-time password device may display 6 characters at a time. The MF OTP device is *something you have*, and it may be activated by either *something you know* or *something you are*.

####5.5.1. Multi-Factor OTP Authenticators

Multi-factor OTP authenticators operate in a similar manner to single-factor OTP verifiers (see section 5.4.1), except that they require the entry of either a memorized secret or use of a biometric to obtain a password from the authenticator. Each use of the authenticator MUST require the input of the additional factor. In the event that the memorized secret or the biometric are incorrect, the authenticator MUST not provide any indication of this; the authenticator MUST output an incorrect password that is indistinguishable from the correct password except by the verifier.

***Need to decide on required complexity of the knowledge factor, and technical requirements on the biometric. Any rate limitations (if output has 64 bit entropy so verifier doesn't rate limit)? Is requirement that it "play dumb" with a biometric activation reasonable? Can additional factor be input electronically, e.g. USB?***

The authenticator output MUST have at least 6 decimal digits (approximately 20 bits) of entropy. The unencrypted key and activation secret or biometric MUST be immediately erased from storage immediately after a password has been generated.

####5.5.2. Multi-Factor OTP Verifiers

Multi-factor OTP verifiers effectively duplicate the process of generating the OTP used by the authenticator, but without the requirement that a second factor be provided. As such, the symmetric keys used by authenticators MUST be strongly protected against compromise.

If the authenticator output has less than 64 bits of entropy, the verifier MUST implement a throttling mechanism that effectively limits the number of failed authentication attempts an Attacker can make on the Subscriber’s account to 100 or fewer in any 30-day period. See section TBD for further guidance on throttling. ***What about rate limiting when the activation secret is only 6 digits?***
    
###5.6. Single Factor Cryptographic Devices

A single-factor cryptographic device is a hardware device that performs cryptographic operations on input provided to the device. This device does not require activation through a second factor of authentication. This device uses embedded symmetric or asymmetric cryptographic keys. Authentication is accomplished by proving possession of the device. The authenticator output is highly dependent on the specific cryptographic device and protocol, but it is generally some type of signed message.

####5.6.1 Single Factor Cryptographic Device Authenticators

Single-factor cryptographic device authenticators encapsulate a secret key that is unique to the device and MUST NOT be exportable (removed from the device). They operate by signing a challenge nonce, usually presented through a direct computer interface such as a USB port.

The secret key MUST be a 128-bit or longer AES key or of equivalent strength (e.g., 256-bit ECDSA or 3072-bit RSA). The challenge nonce MUST be at least 64 bits in length. The authenticator output is normally provided via a computer interface (usually the same one from which the challenge value was received).

Single-factor cryptographic device authenticators SHOULD require a physical input such as the pressing of a button in order to operate. This provides defense against unintended operation of the device, which might occur if the device to which it is connected is compromised.

####5.6.2. Single Factor Cryptographic Device Verifiers

Single-factor cryptographic device verifiers generate a challenge nonce, send it to the corresponding authenticator, and use the authenticator output to verify possession of the device. The authenticator output is highly dependent on the specific cryptographic device and protocol, but it is generally some type of signed message.

The verifier contains either symmetric or asymmetric public keys corresponding to each authenticator. While both types of keys MUST be protected against modification, symmetric keys MUST additionally be strongly protected against unauthorized disclosure.

The challenge nonce MUST be at least 64 bits in length, and MUST either be unique over the lifetime of the authenticator or statistically unique (generated using an approved random number generator).
    
###5.7. Multi-Factor Cryptographic Software

A multi-factor software cryptographic authenticator is a cryptographic key is stored on disk or some other “soft” media that requires activation through a second factor of authentication. Authentication is accomplished by proving possession and control of the key. The authenticator output is highly dependent on the specific cryptographic protocol, but it is generally some type of signed message. The MF software cryptographic authenticator is *something you have*, and it may be activated by either *something you know* or *something you are*.

####5.7.1. Multi-Factor Cryptographic Software Authenticators

Multi-factor software cryptographic authenticators encapsulate a secret key that is unique to the authenticator and is accessible only through the input of an additional factor, either a memorized secret or a biometric. 

***Wondering about the use of a biometric here: how is it possible to meet FIPS 140-2 Level 1 requirements in a software container if it is activated by a biometric also input in software? Seems we need hardware here somewhere.***

Each authentication operation using the authenticator MUST require the input of the additional factor. In the event that the memorized secret or the biometric are incorrect, the authenticator MUST not provide any indication of this; the authenticator MUST output an incorrect value that is indistinguishable from a correct one except by the verifier.

The unencrypted secret key and activation secret or biometric MUST be immediately erased from storage immediately after an authentication transaction has taken place.

####5.7.2. Multi-Factor Cryptographic Software Verifiers

The requirements for a multi-factor cryptographic software verifier are identical to those for a multi-factor cryptographic device verifier, described in Section 5.8.2.

###5.8. Multi-Factor Cryptographic Devices

A multi-factor cryptographic device is a hardware device that contains a protected cryptographic key that requires activation through a second authentication factor. Authentication is accomplished by proving possession of the device and control of the key. The authenticator output is highly dependent on the specific cryptographic device and protocol, but it is generally some type of signed message. The MF Cryptographic device is *something you have*, and it may be activated by either *something you know* or *something you are*.

####5.8.1. Multi-Factor Cryptographic Device Authenticators

Multi-factor cryptographic device authenticators use tamper-resistant hardware to encapsulate a secret key that is unique to the authenticator and is accessible only through the input of an additional factor, either a memorized secret or a biometric.

Each authentication operation using the authenticator MUST require the input of the additional factor. ***Can we require this? Not clear that PIV cards do this.*** Input of the additional factor MAY be accomplished via either direct input on the device or via a hardware connection (e.g., USB or ***what do we call the smartcard interface?***). 

***Do we rate limit at the authenticator or the verifier? Better visibility if done at the verifier, but it doesn't know what the entropy of the activation secret is.***

####5.8.2 Multi-Factor Cryptographic Device Verifiers

Multi-factor cryptographic device verifiers generate a challenge nonce, send it to the corresponding authenticator, and use the authenticator output to verify possession of the device and activation factor. The authenticator output is highly dependent on the specific cryptographic device and protocol, but it is generally some type of signed message.

The verifier contains either symmetric or asymmetric public keys corresponding to each authenticator. While both types of keys MUST be protected against modification, symmetric keys MUST additionally be strongly protected against unauthorized disclosure.

The challenge nonce MUST be at least 64 bits in length, and MUST either be unique over the lifetime of the authenticator or statistically unique (generated using an approved random number generator). The verification operation MUST use approved cryptography.

***Attestation certificate verification? Otherwise how do we know it's a multifactor authentication? Issuer trust?***





